# -*- coding: utf-8 -*-
"""RLT_Suppliers_and_Filter_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NT3BfiaFRXyK5MokBzKG11ZFqx7ebquE
"""

import os
import pandas as pd
import numpy as np
from django.conf import settings
pd.options.mode.chained_assignment = None


class FilterBase():

	def __init__(self, price_min, price_max, okved, deadline):
		self.price_min = price_min
		self.price_max = price_max 
		self.okved = okved
		self.deadline = deadline
	
	def make(self):
		datapath = os.path.abspath(r'C:\virtualenvs\Site\main\data\hack_2023_04_200k')


		cols = ['id_contract','sign_date','contract_price_rub','execution_start_date','execution_end_date','supplier_inn']
		contract_main_info = pd.read_csv(os.path.join(datapath, "contract_main_info.csv"),
										 encoding='utf-8', 
										 sep=';',
										 usecols=cols)

		# привести ИНН поставщиков из флоат к инт
		contract_main_info['supplier_inn'] = contract_main_info['supplier_inn'].fillna(-1)
		contract_main_info['supplier_inn'] = contract_main_info['supplier_inn'].astype('int64')

		# сконвертирвать даты
		contract_main_info['execution_start_date'] = pd.to_datetime(contract_main_info['execution_start_date'], 
														   infer_datetime_format=True, 
														   errors = 'coerce')

		contract_main_info['execution_end_date'] = pd.to_datetime(contract_main_info['execution_end_date'], 
														   infer_datetime_format=True, 
														   errors = 'coerce')

		contract_main_info['sign_date'] = pd.to_datetime(contract_main_info['sign_date'], 
														   infer_datetime_format=True, 
														   errors = 'coerce')

		# оставить только реальные ИНН поставщиков
		suppliers = contract_main_info[contract_main_info['supplier_inn'] >= 1000000000]

		# загрузить справочник ОКПД
		# okpd_2 = pd.read_excel(os.path.join(datapath, "okpd.xlsx"))
		#cols = ['code','name']
		okpd_2 = pd.read_csv(os.path.join(datapath, "okpd.csv"))

		# загрузить справочник контракт - код ОКПД
		contract_item_info = pd.read_csv(os.path.join(datapath, "contract_item_info.csv"),
										 encoding='utf-8', sep=';')

		# смержить их, чтоб получить человекочитаемые коды ОКПД, некоторых кодов в справочнике ОКПД нет, они заменены на Не определено
		contract_item_info_okpd_name = contract_item_info.merge(okpd_2, 
																how='left', 
																left_on='tru_okpd2_code', 
																right_on='code')

		contract_item_info_okpd_name.drop('code', axis=1, inplace=True)
		contract_item_info_okpd_name['name'] = contract_item_info_okpd_name['name'].fillna('Не определено')

		# при внутреннем мерже потеряно 10 записей, для которых не найдено контракта
		suppliers_okpd = suppliers.merge(contract_item_info_okpd_name,
										how='inner',
										left_on='id_contract',
										right_on='id_contract')

		# test_df = suppliers_okpd.copy(deep=True)

		# оставить только те записи, где есть или дата sign_date или execution_start_date
		suppliers_okpd = suppliers_okpd[(suppliers_okpd['sign_date'].notna()) | (suppliers_okpd['execution_start_date'].notna())]
		suppliers_okpd = suppliers_okpd[suppliers_okpd['execution_end_date'].notna()]

		# если отсутствует дата начала договора, заменить ее на дату подписания
		suppliers_okpd['execution_start_date'] = suppliers_okpd['execution_start_date'].fillna(suppliers_okpd['sign_date'])

		# посчитать время исполнения договора в днях
		suppliers_okpd['execution_in_days'] = suppliers_okpd['execution_end_date'] - suppliers_okpd['execution_start_date']
		suppliers_okpd['execution_in_days'] = suppliers_okpd['execution_in_days'].dt.days

		# выбранный ОКВЭД
		# okved = '35.13.10.000'
		# okved = '21.20.10.236'
		okved = self.okved

		# отдельный ДФ для оквэда
		test_okved = suppliers_okpd[suppliers_okpd['tru_okpd2_code'] == okved]

		# считаем статистики для корректного выбора поставщиков по цене и времени исполнения заказа
		# попадают все поставщики, которые подходят по цене и у которых почти-минимальный (25-перцентиль) срок исполнения заказа меньше указанного

		def q1(x):
			return x.quantile(0.25)

		def q3(x):
			return x.quantile(0.75)

		f = [q1, q3]

		grouped_okved = test_okved.groupby(['supplier_inn'])[['contract_price_rub', 'execution_in_days']].agg(f).reset_index()

		# преобразуем таблицу из мультииндекса с ненужными столбцами в плоскую таблицу
		grouped_okved['contract_price_rub_q1'] = grouped_okved['contract_price_rub']['q1']
		grouped_okved['contract_price_rub_q3'] = grouped_okved['contract_price_rub']['q3']
		grouped_okved['execution_in_days_q1'] = grouped_okved['execution_in_days']['q1']

		# оставляем нужные столбцы
		grp_flatten = grouped_okved[['supplier_inn', 'contract_price_rub_q1', 'contract_price_rub_q3', 'execution_in_days_q1']]

		# указанный ценовой диапазо и дедлайн заказа
		price_min = self.price_min
		price_max = self.price_max
		deadline = self.deadline

		# фильтруем датафрейм по параметрам, если заказчик подходит по условиям то 1 иначе 0
		# можно ставить как ценовой диапазон так и конкретную сумму (в обоих полях должна быть одинаковая)

		grp_flatten.loc[(grp_flatten['contract_price_rub_q1'] <= price_max) & (grp_flatten['contract_price_rub_q3'] >= price_min), 'price_good'] = 1
		grp_flatten.loc[(grp_flatten['execution_in_days_q1'] <= deadline), 'deadline_good'] = 1
		grp_flatten[['price_good', 'deadline_good']] = grp_flatten[['price_good', 'deadline_good']].fillna(0)

		# финальная выборка прошедших первый фильтр
		res = grp_flatten[(grp_flatten['price_good'] == 1) & (grp_flatten['deadline_good'] == 1)]
		
		cols_to_rename = {'contract_price_rub_q1':'Нижняя допустимая цена, руб',
					'contract_price_rub_q3':'Верхняя допустимая цена, руб',
					'execution_in_days_q1':'Планируемое время исполнения, дней',
					'price_good':'Подходит по цене',
					'deadline_good':'Подходит по сроку',}
		
		res.rename(columns=cols_to_rename, inplace=True)
		res['supplier_inn'].to_csv(os.path.join(datapath, "good_suppliers_inn.csv"), index=False)
		res.to_csv(os.path.join(datapath, "prepared_res.csv"), index=False)
		
		return res
	





